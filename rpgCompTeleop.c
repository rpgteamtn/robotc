#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftBack,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     liftMotor,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinner,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     rightFront,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     rightBack,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    spinnerServo,         tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    tipperServo,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_6,    goalCapture,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MUX1 		 msensor_S4_1 //Definitions for mux sensors
#define touch    msensor_S4_3
#define GOVLIMIT 3000 //Encoder value when lift is too high to drive fast
#define deadZone 20 //If joystick value is within the absolute value of this, ignore
#define CENTERGOAL 24000
#define GOAL90 21000
#define GOAL60 13000

#include "IRsensor.c" //IR functions
#include "fourWheelMovement.c" //Big robot movement functions
#include "lego-touch.h" //Touch sensor functions
const tMUXSensor LTOUCH = msensor_S4_3; //Defining touch sensor
#include "gyroSensor.c" //Gyro functions
#include "servoFunctions.c" //servo functions
#include "liftFunctions.c" //Lift and spinner functions
#include "MovementCommon.c" //Math functions or calculations

int maxHeight = -29000;
float GOVERNOR = 1.5; //The denominator for the drive motors' ;power

void initializeRobot() //Initialize function for teleop
{
	spinnerRelease(); //Let the spinner lower
	goalRelease(); //pull the goal capture servo up
	resetLiftEncoders();
	tipCatch();
	return;
}

task main()
{
	disableDiagnosticsDisplay(); //Clear the screen

	initializeRobot(); //Initialize

	waitForStart();   // wait for start of tele-op phase

	string state = "catch";
	string goal = "release";

	while (true) //Infinite loop
	{
		getJoystickSettings(joystick);  // Update Buttons and Joysticks
		wait1Msec(10); //Give it a moment to rest
		int liftEnc = nMotorEncoder[liftMotor];
		displayCenteredTextLine(2, "liftEnc = %i", liftEnc);
		int value = TSreadState(LTOUCH);
		displayCenteredTextLine(1, "touch = %i", value);

		/*--------------------------
		controller one
		-------------------------*/
		/*-------------------------
		mapping
		---------------------------
		up =
		down =
		left =
		right =
		joystick left = left motors
		joystick right = right motors
		A =
		B =
		X =
		Y =
		LT = strafe left
		LB = goal capture down
		RT = strafe right
		RB = goal capture up
		---------------------------*/

		// If lift is too high slow the driver motors
		/*if(nMotorEncoder[liftMotor] < GOVLIMIT) {
		GOVERNOR = 1; // Automatically set GOVERNOR as 1 (if lift is down)
		} else {
		GOVERNOR = 2; //Otherwise, set governor as 2
		}*/

		// Drive the robot from joystick 1
		if((abs(joystick.joy1_y1) >= deadZone) || (abs(joystick.joy1_y2) >= deadZone)) /*If either joystick is active*/
		{setMotion(joystick.joy1_y1 / GOVERNOR, joystick.joy1_y2 / GOVERNOR);
			//The left motors are set at a rescaled value of the left joystick's value, and the same for right
		} //If lift is down, GOVERNOR is 1 and doesn't affect movement.  If not, speed is cut in half
		else if(joy1Btn(JOY_BUTTON_LT)) {
			strafe(-50); //Press the left trigger to strafe left
		}
		else if(joy1Btn(JOY_BUTTON_RT)) {
			strafe(50); //Press the right trigger to strafe right
		}
		else {
			stopMotors(); //No joystick info?  Stop drive motors.
		}

		if(joy1Btn(JOY_BUTTON_RB))
		{
			int iCRate = servoChangeRate[goalCapture];	// Save change rate
			servoChangeRate[goalCapture] = 0; 					// Max Speed
			servo[goalCapture] = CATCHDOWN;					    // Set servo position
			wait1Msec(20);
			servoChangeRate[goalCapture] = iCRate;			// Reset the servo
		}

		if(joy1Btn(JOY_BUTTON_LB))
		{ int iCRate = servoChangeRate[goalCapture];	// Save change rate
			servoChangeRate[goalCapture] = 0; 					// Max Speed
			servo[goalCapture] = CATCHSAVE;					      // Set servo position
			wait1Msec(20);
			servoChangeRate[goalCapture] = iCRate;			// Reset the servo
		}

		if(joy1Btn(JOY_BUTTON_X))
		{ int iCRate = servoChangeRate[goalCapture];	// Save change rate
			servoChangeRate[goalCapture] = 0; 					// Max Speed
			servo[goalCapture] = CATCHUP;					      // Set servo position
			wait1Msec(20);
			servoChangeRate[goalCapture] = iCRate;			// Reset the servo
		}

		/*--------------------------
		controller two
		-------------------------*/
		/*-------------------------
		mapping
		---------------------------
		up =
		down =
		left =
		right =
		joystick left = spinner
		joystick right = lift manual control
		A = lift to 30cm
		B = lift to 60cm
		X = lift to 120cm (Center goal)
		Y = lift to 90cm
		LB = bucket down
		LT = bucket up
		RB =
		RT = lift down
		---------------------------*/
		// Raise/lower the lift
		int touchState = TSreadState(LTOUCH);
		displayCenteredTextLine(4, "touch = %i", touchState);

		if(abs(joystick.joy2_y2) > deadZone)
		{
			stopLiftTask(); //first, ensure that robot is not already moving the lift

			if((joystick.joy2_y2 <= 0) && (TSreadState(LTOUCH) == 1))
			{
				lift(0);// if touch sensor is active and driver says go down, stop the lift (don't burn out motor)
				nMotorEncoder[liftMotor] = 0; //The lift is down, so set lift encoder to 0
			}
			else
			{      //If touch is NOT active or driver says go up
				if((Lheight <= maxHeight)&&(joystick.joy2_y2 >= 0 ))
				{
					lift(0);
				}
				else
				{
					int iCRate = servoChangeRate[goalCapture];	// Save change rate
					servoChangeRate[tipperServo] = 0; 					// Max Speed
					servo[tipperServo] = COLLECT;					    // Set servo position
					wait1Msec(20);
					servoChangeRate[goalCapture] = iCRate;			// Reset the servo
					lift(rescale(joystick.joy2_y2)); //Raise lift at a rescaled value of the joystick
				}
			}
		}
		else
		{ //No controls?
			lift(0); //Stop lift motors.
		}

		// Set the lift to preset heights

		/*THE LIFT IS NOT WORKING CORRECTLY RIGHT NOW, SO THESE BUTTON COMMANDS ARE COMMENTED.  WHEN THE LIFT WORKS,
		THESE WILL HAVE THE LIFT GO TO PRESET HEIGHTS TO SCORE EASILY AND QUICKLY TO THE RIGHT GOALS*/

		/*if(joy2Btn(JOY_BUTTON_A)) {
		liftHeight(35);
		} else if(joy2Btn(JOY_BUTTON_B)) {
		liftHeight(65);
		}	else if(joy2Btn(JOY_BUTTON_Y)) {
		liftHeight(95);
		} else if(joy2Btn(JOY_BUTTON_X)) {
		liftHeight(115);
		} else if(joy2Btn(JOY_BUTTON_RT)) {
		liftHeight(0);
		nMotorEncoder[liftRight] = 0;
		}*/

		// Run the spinner to pick up balls
		if((abs(joystick.joy2_y1)) >= deadZone)
		{ // If the left joystick is actve
			spin(rescale(joystick.joy2_y1)); //Run the spinner at the rescaled value of joystick
		}

		else
		{
			spin(0); //Joystick not active?  Stop spinner.
		}

		if(joy2Btn(JOY_BUTTON_B))
		{ int iCRate = servoChangeRate[tipperServo];	// Save change rate
			servoChangeRate[tipperServo] = 0; 					// Max Speed
			servo[tipperServo] = DUMP;					// Set servo position
			wait1Msec(20);
			servoChangeRate[tipperServo] = iCRate;
		}

		if(joy2Btn(JOY_BUTTON_A))
		{ int iCRate = servoChangeRate[tipperServo];	// Save change rate
			servoChangeRate[tipperServo] = 10; 					// Max Speed
			servo[tipperServo] = COLLECT;					// Set servo position
			wait1Msec(20);
			servoChangeRate[tipperServo] = iCRate;
		}

	}
}
