#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftBack,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     liftMotor,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinner,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     rightFront,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     rightBack,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    spinnerServo,         tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    tipperServo,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_6,    goalCapture,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MUX1 		 msensor_S4_1 //Definitions for mux sensors
#define touch 	 msensor_S4_2
#define sonar    msensor_S4_3

#include "IRsensor.c" //IR functions
#include "fourWheelMovement.c" //Big robot movement functions
#include "liftFunctions.c" //Lift and spinner functions
#include "gyroSensor.c" //Gyro functions
#include "MovementCommon.c" //Math functions or calculations
#include "lego-touch.h" //Touch sensor functions
#include "servoFunctions.c" //servo functions

#define GOVLIMIT 3000 //Encoder value when lift is too high to drive fast
#define deadZone 20 //If joystick value is within the absolute value of this, ignore
float GOVERNOR = 1.0; //The denominator for the drive motors' power

//const tMUXSensor LTOUCH = msensor_S4_1; //Defining touch sensor

void initializeRobot() //Initialize function for teleop
{
	spinnerRelease(); //Let the spinner lower
	goalRelease(); //pull the goal capture servo up
	resetLiftEncoders();
}

task main()
{
	disableDiagnosticsDisplay(); //Clear the screen

	initializeRobot(); //Initialize

	waitForStart();   // wait for start of tele-op phase

	string state = "catch";
	string goal = "release";

	while (true) //Infinite loop
	{
		getJoystickSettings(joystick);  // Update Buttons and Joysticks
		wait1Msec(10); //Give it a moment to rest
		int liftEnc = nMotorEncoder[liftMotor];
		displayCenteredTextLine(2, "liftEnc = %i", liftEnc);

		/*--------------------------
		controller one
		-------------------------*/
		/*-------------------------
		mapping
		---------------------------
		up =
		down =
		left =
		right =
		joystick left = left motors
		joystick right = right motors
		A =
		B =
		X =
		Y =
		LT = strafe left
		LB = goal capture down
		RT = strafe right
		RB = goal capture up
		---------------------------*/

		// If lift is too high slow the driver motors
		/*if(nMotorEncoder[liftMotor] < GOVLIMIT) {
		GOVERNOR = 1; // Automatically set GOVERNOR as 1 (if lift is down)
		} else {
		GOVERNOR = 2; //Otherwise, set governor as 2
		}*/

		// Drive the robot from joystick 1
		if((abs(joystick.joy1_y1) >= deadZone) || (abs(joystick.joy1_y2) >= deadZone)) /*If either joystick is active*/
		{setMotion(joystick.joy1_y1 / GOVERNOR, joystick.joy1_y2 / GOVERNOR);
			//The left motors are set at a rescaled value of the left joystick's value, and the same for right
		} //If lift is down, GOVERNOR is 1 and doesn't affect movement.  If not, speed is cut in half
		else if(joy1Btn(JOY_BUTTON_LT)) {
			strafe(-50); //Press the left trigger to strafe left
		}
		else if(joy1Btn(JOY_BUTTON_RT)) {
			strafe(50); //Press the right trigger to strafe right
		}
		else {
			stopMotors(); //No joystick info?  Stop drive motors.
		}

		if(joy1Btn(JOY_BUTTON_RB))
		{ int iCRate = servoChangeRate[goalCapture];	// Save change rate
			servoChangeRate[goalCapture] = 0; 					// Max Speed
			servo[goalCapture] = CATCHDOWN;					    // Set servo position
			wait1Msec(20);
			servoChangeRate[goalCapture] = iCRate;			// Reset the servo
		}

		if(joy1Btn(JOY_BUTTON_LB))
		{ int iCRate = servoChangeRate[goalCapture];	// Save change rate
			servoChangeRate[goalCapture] = 0; 					// Max Speed
			servo[goalCapture] = CATCHUP;					      // Set servo position
			wait1Msec(20);
			servoChangeRate[goalCapture] = iCRate;			// Reset the servo
		}


		/*--------------------------
		controller two
		-------------------------*/
		/*-------------------------
		mapping
		---------------------------
		up =
		down =
		left =
		right =
		joystick left = spinner
		joystick right = lift manual control
		A = lift to 30cm
		B = lift to 60cm
		X = lift to 120cm (Center goal)
		Y = lift to 90cm
		LB = bucket down
		LT = bucket up
		RB =
		RT = lift down
		---------------------------*/
		// Raise/lower the lift
		if(abs(joystick.joy2_y2) > deadZone) {
			stopLiftTask(); //first, ensure that robot is not already moving the lift
			int iCRate = servoChangeRate[tipperServo];	// Save change rate
			servoChangeRate[tipperServo] = 10; 					// Max Speed
			servo[tipperServo] = 175;					// Set servo position
			wait1Msec(20);
			servoChangeRate[tipperServo] = iCRate;
			lift(rescale(joystick.joy2_y2)); //Raise lift at a rescaled value of the joystick
			} else { //No controls?
			lift(0); //Stop lift motors.
		}

		// Set the lift to preset heights

		/*THE LIFT IS NOT WORKING CORRECTLY RIGHT NOW, SO THESE BUTTON COMMANDS ARE COMMENTED.  WHEN THE LIFT WORKS,
		THESE WILL HAVE THE LIFT GO TO PRESET HEIGHTS TO SCORE EASILY AND QUICKLY TO THE RIGHT GOALS*/

		/*if(joy2Btn(JOY_BUTTON_A)) {
		liftHeight(35);
		} else if(joy2Btn(JOY_BUTTON_B)) {
		liftHeight(65);
		}	else if(joy2Btn(JOY_BUTTON_Y)) {
		liftHeight(95);
		} else if(joy2Btn(JOY_BUTTON_X)) {
		liftHeight(115);
		} else if(joy2Btn(JOY_BUTTON_RT)) {
		liftHeight(0);
		nMotorEncoder[liftRight] = 0;
		}*/

		// Run the spinner to pick up balls
		if((abs(joystick.joy2_y1)) >= deadZone) { // If the left joystick is actve
			spin(abs(rescale(joystick.joy2_y1))); //Run the spinner at the rescaled value of joystick
			} else {
			spin(0); //Joystick not active?  Stop spinner.
		}

		if(joy2Btn(JOY_BUTTON_LB))
		{ int iCRate = servoChangeRate[tipperServo];	// Save change rate
			servoChangeRate[tipperServo] = 0; 					// Max Speed
			servo[tipperServo] = DUMP;					// Set servo position
			wait1Msec(20);
			servoChangeRate[tipperServo] = iCRate;
		}

		if(joy2Btn(JOY_BUTTON_RB))
		{ int iCRate = servoChangeRate[tipperServo];	// Save change rate
			servoChangeRate[tipperServo] = 10; 					// Max Speed
			servo[tipperServo] = COLLECT;					// Set servo position
			wait1Msec(20);
			servoChangeRate[tipperServo] = iCRate;
		}

	}
}
