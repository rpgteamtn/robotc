/*#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     spinner,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftBack,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     liftRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     rightFront,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     rightBack,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C1_1,    spinnerServo,         tServoStandard)
#pragma config(Servo,  srvo_S2_C1_6,    goalCapture,          tServoStandard)*/
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*#define MUX1 		 msensor_S4_1
#define touch 	 msensor_S4_2
#define sonar    msensor_S4_3

#include "IRsensor.c"
#include "fourWheelMovement.c"
#include "gyroSensor.c"
#include "MovementCommon.c"
#include "sonarSensor.c"*/

//distances for finding the kickstand
#define pointA 70
#define pointB 90
#define pointC 150
#define pointD 50
#define maxDistance 150
#define distanceA1 100.0
#define distanceA2 150.0
#define distanceB1 230.0
#define distanceB2 18.0
#define distanceB3 13.0
#define distanceC1 /*160.0*/ 50.0
#define distanceC2 200.0
#define distanceD1 50
#define distanceD2 200
#define distanceD3 200
#define distanceE1 130
#define distanceE2 70
#define pointX 1
#define pointY 1
#define pointZ 1
#define timeX1 100
#define distanceX1 1
#define distanceX2 1
#define distanceY1 1
#define distanceY2 1
#define distanceZ1 1
#define distanceZ2 1
#define distanceZ3 1

#define maxEncoder 5000


// Finds the IR and displays the encoders
float findIRGround(eWay direct)
{
	resetEncoders();
	int	ir_value = getIRReading();
	if (direct == dForward) {
		forward(50);
	}
	else if (direct == dLeft) {
		backward(50);
	}
	wait1Msec(100);
	repeatUntil((ir_value == 2)||(ir_value == 3)||(abs(nMotorEncoder(leftFront))>maxEncoder))
	{
		wait1Msec(1);
		ir_value = getIRReading();
	}
	stopMotors();
	int lfEnc = (abs(nMotorEncoder[leftFront]));// + abs(nMotorEncoder[rightFront])) / 2;
	int lbEnc = (abs(nMotorEncoder[leftBack]));// + abs(nMotorEncoder[rightFront])) / 2;
	int rfEnc = (abs(nMotorEncoder[rightFront]));// + abs(nMotorEncoder[rightFront])) / 2;
	int rbEnc = (abs(nMotorEncoder[rightBack]));// + abs(nMotorEncoder[rightFront])) / 2;
	float avgEnc = (lfEnc + rfEnc) / 2.0;

	displayCenteredTextLine(2, "lf enc=%i", lfEnc);

	displayCenteredTextLine(3, "lb enc=%i", lbEnc);

	displayCenteredTextLine(4, "rf enc=%i", rfEnc);

	displayCenteredTextLine(5, "rb enc=%i", rbEnc);

	displayCenteredTextLine(6, "avg enc = %f", avgEnc);

	float distance = calculateDist(avgEnc);

	displayCenteredTextLine(7, "dist = %f", distance);

	return distance;
}

float findIRRamp(eWay direct)
{
	resetEncoders();
	int	ir_value = getIRReading();
	if (direct == dForward) {
		forward(50);
	}
	else if (direct == dLeft) {
		backward(50);
	}
	wait1Msec(100);
	repeatUntil((ir_value == 2)||(ir_value == 1)||(abs(nMotorEncoder(leftFront))>maxEncoder))
	{
		wait1Msec(1);
		ir_value = getIRReading();
	}
	stopMotors();
	int lfEnc = (abs(nMotorEncoder[leftFront]));// + abs(nMotorEncoder[rightFront])) / 2;
	int lbEnc = (abs(nMotorEncoder[leftBack]));// + abs(nMotorEncoder[rightFront])) / 2;
	int rfEnc = (abs(nMotorEncoder[rightFront]));// + abs(nMotorEncoder[rightFront])) / 2;
	int rbEnc = (abs(nMotorEncoder[rightBack]));// + abs(nMotorEncoder[rightFront])) / 2;
	float avgEnc = (lfEnc + rfEnc) / 2.0;

	displayCenteredTextLine(2, "lf enc=%i", lfEnc);

	displayCenteredTextLine(3, "lb enc=%i", lbEnc);

	displayCenteredTextLine(4, "rf enc=%i", rfEnc);

	displayCenteredTextLine(5, "rb enc=%i", rbEnc);

	displayCenteredTextLine(6, "avg enc = %f", avgEnc);

	float distance = calculateDist(avgEnc);

	displayCenteredTextLine(7, "dist = %f", distance);

	return distance;
}

void strategyA()//use if in position 1
{
	string text;
	sprintf(text, "Strategy A");
	displayCenteredTextLine(1, text);
	travelDistance(distanceA1, dBackward);
	stopMotors();
	strafe(50);
	wait1Msec(1000);
	stopMotors();
	gyroTurn(30, 80, dLeft);
	travelDistance(distanceA2, dBackward);
}

void strategyB()//use if in position 2
{
	string text;
	sprintf(text, "Strategy B");
	displayCenteredTextLine(1, text);
	strafe(50);
	wait1Msec(1000);
	stopMotors();
	gyroTurn(30, 35, dLeft);
	travelDistance(distanceB1, dBackward);
}

void strategyC()//use if in position 3
{
	displayCenteredTextLine(1, "Strategy C");
	strafe(50);
	wait1Msec(2700);
	stopMotors();
	gyroTurn(30, 5, dRight);
	travelDistance(distanceC2, dBackward);
/*	string text;
	sprintf(text, "Strategy C");
	displayCenteredTextLine(1, text);
	gyroTurn(30, 90, dRight);
	travelDistance(distanceA2, dForward);
	gyroTurn(30, 90, dRight);
	travelDistance(distanceC1, dBackward);*/
}

void strategyD()
{
	displayCenteredTextLine(1, "Strategy D");
	travelDistance(distanceD1, dForward);
	gyroTurn(30, 90, dRight);
	travelDistance(distanceD2, dForward);
	gyroTurn(30, 90, dRight);
	travelDistance(distanceD3, dForward);
}

void strategyX() //use if in position 3 (IR toward parking)
{
	displayCenteredTextLine(1, "strategy X");
	strafe(50);
	wait1Msec(timeX1);
	stopMotors();
	wait1Msec(10);
	travelDistance(distanceX1, dForward);
	wait1Msec(10);
	gyroTurn(30, 80, dLeft);
	wait1Msec(10);
	travelDistance(distanceX2, dForward);
}

void strategyY() //use if in position 2
{
	displayCenteredTextLine(1, "strategy Y");
	travelDistance(distanceY1, dForward);
	gyroTurn(30, 45, dLeft);
	travelDistance(distanceY1, dForward);
}

void strategyZ() //use if in position 1
{
	displayCenteredTextLine(1, "strategy Z");
	travelDistance(distanceZ1, dForward);
	gyroTurn(30, 90, dLeft);
	travelDistance(distanceZ2, dForward);
	gyroTurn(30, 90, dRight);
	travelDistance(distanceZ3, dForward);
}

float rampOff()
{
	float distance = findIRRamp(dBackward);
	float travelDist = 170 - distance;
	travelDistance(travelDist, dForward);
	gyroTurn(30, 80, dRight);
	wait1Msec(15000);
	return distance;
}

void autoRamp()
{
	disableDiagnosticsDisplay();
	resetEncoders();
	float travelled = abs(rampOff());
	wait1Msec(500);

	if (travelled < pointZ)
	{
		strategyZ();
	}
	else if (travelled < pointX)
	{
		strategyX();
	}
	else if (travelled < pointY)
	{
		strategyY();
	}
}

void autoKickstand()
{
	disableDiagnosticsDisplay();
	//	waitForStartOrButton();
	resetEncoders();
	eraseDisplay();
	float travelled = abs(findIRGround(dForward));
	wait1Msec(500);

	if(travelled <= pointD)
	{
		travelDistance(distanceD1, dForward);
		strategyC();
	}

	else if(travelled <= pointA)
	{
		strategyA();
	}
	else if(travelled <= pointB)
	{
		strategyB();
	}
	else if(travelled <= pointC)
	{
		strategyC();
	}


	/*wait1Msec(20);
	travelDistance(distanceE1, dBackward);
	wait1Msec(20);
	align(10, dLeft);
	strafe(50);
	wait1Msec(500);
	/*gyroTurn(30, 90, dRight);
	approach(50);*/
}

/*task main()
{
autoRamp();
}*/
